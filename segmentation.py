from pathlib import Path
from typing import Union, List, Dict, Optional

import torch
import numpy as np
from PIL import Image
import matplotlib.pyplot as plt

from mobile_sam import sam_model_registry, SamAutomaticMaskGenerator


class Segmentation:
    """
    Class for segmenting images using MobileSAM.

    Parameters
    ----------
    checkpoint_path: str
        Path to MobileSAM checkpoint.

    Attributes
    ----------
    mask_generator: SamAutomaticMaskGenerator
        Mask generator.
    img: np.ndarray
        Image to segment.
    masks: List[Dict[str, any]]
        Masks generated by segment_image.
    """
    def __init__(self, checkpoint_path: str) -> None:
        sam_checkpoint = checkpoint_path + "/mobile_sam.pt"
        model_type = "vit_t"

        device = "cuda" if torch.cuda.is_available() else "cpu"

        sam = sam_model_registry[model_type](checkpoint=sam_checkpoint)
        sam.to(device=device)
        sam.eval()

        self.mask_generator = SamAutomaticMaskGenerator(sam)

    def load_image(self, file: Union[str, Path]) -> np.ndarray:
        """
        Loads image from file.

        Parameters
        ----------
        file: str
            Path to image file.

        Returns
        -------
        np.ndarray
            Image as numpy array.
        """
        self.img = np.array(Image.open(file))
        return self.img

    def plot_image(self, image: Optional[np.ndarray] = None, masks: Union[List[Dict[str, any]], None] = None) -> None:
        """
        Plots original image, masks and image with masks overlayed.

        Parameters
        ----------
        image: np.ndarray
            Original image to plot. If None, uses the image loaded by load_image.
        masks: List[Dict[str, any]]
            Masks to plot. If None, uses the masks generated by segment_image.
        """
        if image is None:
            image = self.img

        plt.figure(figsize=(20,20))
        plt.subplot(1, 3, 1)
        plt.imshow(image)
        plt.axis('off')

        blank_image = 255*np.ones_like(image)

        anns = self._get_anns(masks)

        plt.subplot(1, 3, 2)
        plt.imshow(blank_image)
        plt.imshow(anns)
        plt.axis('off')

        plt.subplot(1, 3, 3)
        plt.imshow(image)
        plt.imshow(anns)
        plt.axis('off')

        plt.show()

    def _get_anns(self, anns: Optional[List[Dict[str, any]]] = None) -> np.ndarray:
        """
        Creates blank image with masks overlayed.

        Parameters
        ----------
        anns: List[Dict[str, any]]
            Masks to overlay. If None, uses the masks generated by segment_image.

        Returns
        -------
        np.ndarray
            Image with masks overlayed.
        """
        if anns is None:
            anns = self.masks
        if len(anns) == 0:
            return
        sorted_anns = sorted(anns, key=(lambda x: x['area']), reverse=True)

        img = np.ones((sorted_anns[0]['segmentation'].shape[0], sorted_anns[0]['segmentation'].shape[1], 4))
        img[:,:,3] = 0
        for ann in sorted_anns:
            m = ann['segmentation']
            color_mask = np.concatenate([np.random.random(3), [0.35]])
            img[m] = color_mask

        return img

    def create_segmented_image(self, masks: Optional[List[Dict[str, any]]] = None) -> np.ndarray:
        """
        Creates image with segmentation mask
        
        Parameters
        ----------
        masks: List[Dict[str, any]]
            Masks to overlay. If None, uses the masks generated by segment_image.

        Returns
        -------
        np.ndarray
            Image with masks overlayed.
        """
        masks = masks if masks is not None else self.masks

        sorted_anns = sorted(masks, key=(lambda x: x['area']), reverse=True)
        img = np.ones((sorted_anns[0]['segmentation'].shape[0], sorted_anns[0]['segmentation'].shape[1], 1))
        img[:,:,3] = 0
        idx = 1
        for ann in sorted_anns:
            m = ann['segmentation']
            img[m] = idx
            idx += 1

        return img

    def segment_image(self, image: Optional[Union[np.ndarray, str]] = None) -> List[Dict[str, any]]:
        """
        Segments image.

        Parameters
        ----------
        image: np.ndarray or str
            Image to segment. If None, uses the image loaded by load_image.

        Returns
        -------
        List[Dict[str, any]]
            List of masks.
        """
        if image is None:
            image = self.img
        if type(image) == str:
            image = self.load_image(image)

        self.masks = self.mask_generator.generate(image)

        return self.masks
